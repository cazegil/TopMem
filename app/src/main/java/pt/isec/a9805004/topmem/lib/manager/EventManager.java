package pt.isec.a9805004.topmem.lib.manager;

import com.path.android.jobqueue.CancelResult;
import com.path.android.jobqueue.Job;
import com.path.android.jobqueue.JobManager;
import com.path.android.jobqueue.TagConstraint;

import de.greenrobot.event.EventBus;
import pt.isec.a9805004.topmem.TopMemApp;
import pt.isec.a9805004.topmem.lib.logger.Log;

/**
 *
 */
public class EventManager {

    private final static String TAG = "EventManager";

    private static EventManager sInstance;

    private JobManager mJobManager;

    private EventManager() {
        mJobManager = new JobManager(TopMemApp.getContext());
    }

    public static EventManager getInstance() {
        if (EventManager.sInstance == null) {
            EventManager.sInstance = new EventManager();
        }
        return EventManager.sInstance;
    }

    public static void initialize() {
        long startTime = System.currentTimeMillis();
        getInstance();
        Log.i(TAG, "{0} initialized | {1}ms", TAG, (System.currentTimeMillis() - startTime));
    }

    public static void shutdown() {
        Log.v(TAG, "Shutting down...");
        getInstance().mJobManager.clear();
        getInstance().mJobManager = null;

        sInstance = null;
    }

    // ------------------------------

    /**
     * Submit async handler task to background queue
     *
     * @param request
     */
    public static void submit(Job request) {
        Log.v(TAG, "Submit request to queue | tags={0}", request.getTags());
        getInstance().mJobManager.addJobInBackground(request);
    }

    /**
     * Post update event
     *
     * @param event
     */
    public static void post(Object event) {
        EventBus.getDefault().post(event);
    }

    /**
     * Register event listener. This allows the observer to receive events generated by the lib. To do so, implement the <code>onEvent</code> method
     * with the response object required as the only parameter
     *
     * @param subscriber
     */
    public static void register(Object subscriber) {
        final EventBus eventBus = EventBus.getDefault();
        if (eventBus.isRegistered(subscriber)) {
            eventBus.unregister(subscriber);
        }
        eventBus.register(subscriber);
    }

    /**
     * Unregister event listener
     *
     * @param subscriber
     */
    public static void unregister(Object subscriber) {
        EventBus.getDefault().unregister(subscriber);
    }

    /**
     * Cancel background task by id. This id is returned when the task is scheduled.
     *
     * @param id
     */
    public static void cancel(final String id) {
        Log.v(TAG, "Cancel queue request | id={0}", id);
        getInstance().mJobManager.cancelJobsInBackground(new CancelResult.AsyncCancelCallback() {

            @Override
            public void onCancelled(CancelResult cancelResult) {
                Log.v(TAG, "Job(s) canceled | id: {0}, canceled: {1}, failed: {2}", id, cancelResult.getCancelledJobs().size(),
                      cancelResult.getFailedToCancel().size());
            }
        }, TagConstraint.ALL, id);
    }

}
